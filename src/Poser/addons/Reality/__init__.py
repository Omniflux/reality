##
# \file
# Reality plug-in. This file defines the Reality plugin for Poser.
# 
# Legal:
# Copyright (c) Pret-a-3D/Paolo Ciccone 2012-2013. All rights reserved.
#

import poser,      \
       os,         \
       sys,        \
       wx,         \
       wx.py,      \
       wx.aui,     \
       subprocess, \
       poseraddon, \
       re

from math import pi, atan

from Reality_services import *
import ReTools
from ReGeometryExporter import *
import ReMaterial, ReGUID

#REALITY_VERSION = 4.2

# Parameters used to flag that the scene has changed
RE_SCENE_DIRTY_PARAM = "ReSceneChanged"

# Platform IDs
machineOS = ""
isMacOS = False
isWindows = False
if sys.platform == "darwin":
    machineOS = "MacOS"
    isMacOS = True
elif sys.platform == "win32":
    machineOS = "Windows"
    isWindows = True
bitness = 32        
if sys.maxsize > 2**32:
    bitness = 64

"""
A dictionary of "global" variables. A simple way
to avoid polluting the global namespace and to avoid
conflicts with variables.
"""
Globals = {}

Globals["preferences"] = {}
Globals["frameSize"] = (0,0)
Globals["lastObjMat"] = ""
Globals["cameraData"] = []
Globals["selectedCamera"] = ""

# Export formats as defined in ReDefs.h
LUX_FORMAT        = 0
SLG_FORMAT        = 1
JSON_FORMAT       = 2

# if POSER_MAJOR == 9:    
#     evVISIBILITY_CHANGED = 0x080000
#     evIBL_LIGHT_SELECTED = 0x040000
# else:
#     evVISIBILITY_CHANGED = 0x080010
#     evIBL_LIGHT_SELECTED = 0x000019

# Poser doesn't send the "objectAdded" signal
# for the scene's default IBL light and Distant Light
# We use this flag to signal that we need to scan for
# all the lights the first time that a light is added
Globals["lightsAdded"] = False;


# Poser Units to Meters
PU2Meters = 2.62128
# Reality ID key used to store the object's GUID as CustomData
REALITY_ID="RealityID"

# Frequency of the timer used to refresh the Reality data
RefreshRate = 1500

RealityActive = False
try:
    import Reality
    Reality.writeToLog("Reality for Poser loaded")
    RealityActive = True
except Exception, e:
    wx.MessageBox(
        """
        The Reality plugin could not be loaded.
        You are running Poser at %s bits. 
        Make sure that you have installed Reality at %s bits as well. 
        """ % (poser.Bitness(), poser.Bitness())
    )

RealitySceneData = None
if RealityActive:
    RealitySceneData = Reality.Scene()

"""
Simple lookup table used to convert a light type form Poser
type to Reality type, as defined in ReLight.h
"""
lightTypeConversion = {
    0: 3,  # Infinite
    1: 1,  # Spot
    2: 4,  # Point
    3: 5,  # IBL
    4: 0   # From Area light to Mesh light
}

lightTypeToPoser = {
    3: 0,  # Infinite
    1: 1,  # Spot
    4: 2,  # Point
    5: 3,  # IBL
    0: 4   # Mesh to area
}

# File extension used for the Lux include files
LUX_INCLUDE_EXTENSION = "lxi"

def updateFrameDimensions():
    # Update the frame resolution data
    frame = poser.Scene().OutputRes()
    if not (frame[0] == Globals["frameSize"][0] and frame[1] == Globals["frameSize"][1]):
        RealitySceneData.setFrameSize(frame[0], frame[1])
        Globals["frameSize"] = frame


# import pprint
##
# The Reality Data model is a simple storage class that separates
# the data from the view. 
#
class RealityDataModel:
    # rootObjects = {}
    lightList   = {}
    cameraList  = {}

    ##
    # Scans an object for its materials. The actual scan and conversion is done
    # by the <ReMaterial> class. 
    def collectMaterials(self, actor):
        # global RealitySceneData

        # Needed or some textures will be returned with the 
        # old Mac file separator
        poser.Scene().ResolvePendingTextures()
        try:
            isAreaLight = actor.IsLight() and (actor.LightType() == ReTools.AreaLightType)

            if isAreaLight:
                figID = actor.InternalName()
            else:
                figID = actor.CustomData(REALITY_ID)

            figName = actor.Name()
            mats = actor.Materials()
            if not mats:
                return
            numMats = len(mats)

            # Make sure to minimize the impact of converting the materials
            Reality.startACSELCaching()
            for aMat in mats:
                matName = aMat.Name()
                if isAreaLight and (matName == "lampBase" or matName == "lampFlaps") :
                    continue
                # If there is only one material the we convert it, no matter
                # what the name is. Otherwise, if there are multiple materials
                # the we avoid converting the Preview one because that one is
                # just the material generated by Poser to render the OpenGL
                # preview.
                # The exception to this rule is the AreaLight of Poser 11, which
                # has multiple materials but for which only the Preview material
                # is the meaningful one. Yes, consistency is not strong in the
                # Poser world.
                if numMats == 1 \
                   or (numMats > 1 and matName != "Preview") \
                   or (matName == "Preview" and isAreaLight):
                    # Here is the material conversion proper
                    theMat = ReMaterial.ReMaterial(aMat).getData()
                    RealitySceneData.addMaterial(figID, matName, theMat)
                    if isAreaLight:
                        lightID = RealitySceneData.getLightIDFromMaterial(figID, matName)
                        if lightID != "":
                            Reality.writeToLog("Marking %s as host area light" % lightID)
                            RealitySceneData.setIsHostAreaLight(lightID, True)
                            # # Remove the entry possibly added bu addLight()
                            # self.removeLightFromList(figID)
                            # self.addToLightList(lightID, figID,ReTools.AreaLightType)

                    # Reality.writeToLog("Mat: %s" % pprint.pformat(theMat))
            Reality.stopACSELCaching()

        except Exception, e:
            print "Exception in Reality::DataModel::collectMaterials(%s/%s) => %s" % \
                   (actor.InternalName(), actor.Name(), e.message)
            Reality.stopACSELCaching()


    def updateMaterial(self, material, actor ):
        if not RealityActive:
            return
        try:
            # figID = actor.InternalName()
            figID = actor.CustomData(REALITY_ID)
            if figID and RealitySceneData.hasObject(figID):
                matName = material.Name()
                # If the material exists already and it has been converted to 
                # light then we ignore the change in the host because it makes
                # no sense at this point.
                matType = RealitySceneData.getMaterialShortType(figID, matName)
                if matType == "LGT":
                    return
                theMat = ReMaterial.ReMaterial(material).getData()
                RealitySceneData.updateMaterial(figID, matName, theMat)
        except Exception, e:
            print "Exception in Reality::DataModel::updateMaterial(%s,%s) => %s" % \
                  (material.Name(), actor.Name(), e.message)
            traceback.print_exc(file=sys.stdout)

    ##
    # Change the material type by retrieving the material information from
    # Poser and then calling the Reality library with the new data.
    #
    # !TODO!
    def changeMaterialType(self, objectID, materialID, newType):

        try:
            obj = poser.Scene().Figure(RealitySceneData.getObjectName(objectID))
        except:
            try:
                obj = poser.Scene().Actor(RealitySceneData.getObjectName(objectID))
            except:
                print "Exception in RealitydataModel.changeMaterialType(). Cannot find actor named %s" % objectID
                return

        poserMat = obj.Material(materialID)
        reMat = ReMaterial.ReMaterial(poserMat).getData()
        RealitySceneData.changeMaterialType(
            objectID,
            materialID,
            newType,
            reMat
        )

    # Returns whether an actor is a control for part of a figure or other actor.
    def isControl(self, actor):
        return actor.Name().lower().endswith("_control") and (actor.Parent() != None)

    ##
    # Add an object, a figure, prop, or light, to the data set. It invokes the 
    # collectMaterials() method to gather all the materials associated with the object.
    #
    # See also:
    #
    # <collectMaterials>    
    def addObjects(self, objects):
        # Reality.writeToLog("AddObjects called with %d objects" % len(objects))

        global Globals
        for theObject in objects:
            objName = theObject.Name()
            # Reality.writeToLog("Adding object %s" % objName)

            # This is some internal object used by Poser when replacing an object with 
            # another one
            if objName == "__refRepose__":
                continue
            try:
                isProp = theObject.IsProp()
                if isProp and self.isControl(theObject):
                    continue

                isLight = theObject.IsLight()
                isAreaLight = isLight and (theObject.LightType() == ReTools.AreaLightType)
                # Add Figures or Props
                if isinstance(theObject, poser.FigureType)  \
                   or (isinstance(theObject, poser.ActorType) and isProp):

                    # Skip props that don't have geometry
                    if isProp and not theObject.Geometry():
                        # Reality.writeToLog("%s has no geometry, skipped" % objName)
                        continue

                    if objName.startswith("GoalCent")                \
                       or objName.startswith("CenterOfMass")         \
                       or objName.startswith("FocusDistanceControl") \
                       or theObject.IsDeformer()                     \
                       or theObject.IsBase()                         \
                       or theObject.IsZone() :
                          continue
                    # First check if the ID has been already assigned. This 
                    # can happen from loading an existing scene
                    objID = theObject.CustomData(REALITY_ID)
                    if not objID:
                        objID = ReGUID.makeObjectUID(theObject)
                        theObject.SetCustomData(REALITY_ID, objID, 0, 0)

                    # Is it already added, from the loading of scene data?
                    if RealitySceneData.hasObject(objID):
                        Reality.writeToLog("Found obj %s in database" % objID)
                        # Check if it's exactly the same object or if this
                        # is the result of using the Edit | Duplicate menu
                        # of Poser
                        oldObjName = RealitySceneData.getObjectName(objID)
                        if oldObjName == objName:
                            Reality.writeToLog("  skipping object %s with ID %s" % (objName,objID))
                            continue
                        else:
                            objID = ReGUID.makeObjectUID(theObject)
                            theObject.SetCustomData(REALITY_ID, objID, 0, 0)

                    geomFile = ReTools.getObjectGeometryID(theObject)
                    RealitySceneData.addObject(objName, objID, geomFile)

                    # Collect the materials for the figure
                    self.collectMaterials(theObject)
                    # Let the client side know that there is a new object in the scene
                    Reality.objectAdded(objID)

                elif theObject.IsCamera():
                        cameraID = theObject.InternalName()
                        # Is it already added, from the loading of scene data?
                        if cameraID in self.cameraList:
                            continue

                        # Test if this is a perspective camera. If it is not
                        # the yaw parameter does not exist for this camera
                        yaw = theObject.Parameter("yaw")
                        if yaw:
                            cameraData = self.getCamera(theObject)

                            self.storeCameraData(cameraData["ID"], cameraData["name"], cameraData["focalLength"])
                            RealitySceneData.addCamera(cameraData)

                elif isLight:
                    self.addLight(theObject)
                    if not Globals["lightsAdded"]:
                        self.addAllLights()

            except Exception, e:
                print "Exception in RealityDataModel::addObjects: " + e.message
                traceback.print_exc(file=sys.stdout)

    def getLightMap(self, lightObj):
        """
        All lights have only one material, named Preview
        """
        previewMat = lightObj.Material("Preview")
        lightRootNode = previewMat.ShaderTree().Node(0)
        colorNode = lightRootNode.InputByInternalName("Color").InNode()
        if not colorNode:
            return ""
        imgSrc = colorNode.InputByInternalName("Image_Source")
        if imgSrc:
            return imgSrc.Value()
        return ""

    def getLightData(self, lightObj, lightData):
        try:
            lightType = lightObj.LightType()
            lightData["name"]    = lightObj.Name();
            lightData["lightID"] = lightObj.InternalName();
            # If this is an IBL light then force the use of the ID for IBL defined
            # by Reality
            if lightType == ReTools.IBLLightType:
                lightData["lightID"] = "IBL"
                lightData["name"] = "IBL"
                lightData["IBLMapFormat"] = "angular";
            lightData["on"]      = lightObj.LightOn()

            lightData["type"]    = lightTypeConversion[lightType]
            # The map entry is for future extensions
            lightData["color"]   = {"color": (1.0, 1.0, 1.0), "map": ""}

            # We read the file map from the material shader tree for the light
            lightData["color"]["map"] = self.getLightMap(lightObj)

            if lightType != ReTools.InfiniteLightType:
                lightData["color"]["color"] = (lightObj.ParameterByCode(poser.kParmCodeKDRED).Value(),
                                               lightObj.ParameterByCode(poser.kParmCodeKDGREEN).Value(),
                                               lightObj.ParameterByCode(poser.kParmCodeKDBLUE).Value())
                if lightType == ReTools.SpotLightType:
                    # The kParmCodeLITEFALLOFFEND is the "Angle End" parameter for the
                    # spotlight, which gives us the angle of the light cone
                    param = lightObj.ParameterByCode(poser.kParmCodeLITEFALLOFFEND)
                    if param:
                        lightData["angle"] = param.Value()
                    else:
                        lightData["angle"] = 70
                else:
                    lightData["angle"] = 0

            lightData["intensity"] = lightObj.ParameterByCode(poser.kParmCodeKDINTENSITY).Value()
            lightData["isHostAreaLight"] = lightObj.LightType() == ReTools.AreaLightType
        except Exception, e:
            Reality.writeToLog("Exception in getLightData(): %s" % e.message)


    def addLight(self, lightObj):
        # Avoid adding a light that is already there
        if not self.addToLightList(lightObj):
            Reality.writeToLog("Light {0} already in light list, skipped".format(lightObj.Name()))
            return

        lightData = {}
        self.getLightData(lightObj, lightData)
        lightID = lightData["lightID"]
        isAreaLight = lightObj.LightType() == ReTools.AreaLightType
        # Adding the Poser AreaLight
        if isAreaLight:
            geomFile = ReTools.getObjectGeometryID(lightObj)
            # First check if the ID has been already assigned. This 
            # can happen from loading an existing scene
            objID = lightObj.CustomData(REALITY_ID)
            if not objID:
                lightObj.SetCustomData(REALITY_ID, lightID, 0, 0)
            RealitySceneData.addObject(lightObj.Name(), lightID, geomFile)
            RealitySceneData.markObjectAsLight(lightID, True)
            self.collectMaterials(lightObj)
            # Let the client side know that there is a new object in the scene
            Reality.objectAdded(lightID)

        else:
            RealitySceneData.addLight(lightID, lightData)

        m = lightObj.WorldMatrix()
        RealitySceneData.setLightMatrix(lightID, m)

    def updateLight(self, lightObj):
        lightID = lightObj.InternalName()
        if lightID in self.lightList :
            lightData = {}
            self.getLightData(lightObj, lightData)
            RealitySceneData.updateLight(lightData["lightID"], lightData)

    ##
    # Add all the lights in the scene. This method is necessary because not all lights
    # trigger a "addObject" event in the addon Framework.
    def addAllLights(self):
        # If the user uses the File | Close scene this method will receive 
        # an invalid Scene object. We trap the exception here solely for that
        # situation
        try:
            lights = poser.Scene().Lights()
        except:
            return

        for aLight in lights:
            lightID = aLight.InternalName()
            lightType = aLight.LightType()
            if not lightID in self.lightList:
                self.addLight(aLight)

        Globals["lightsAdded"] = True

    ##
    # Add a new light to the lightList
    # Returns True if the light has been added, False if the light was already 
    # in the list.
    # 
    # It can be called as either addToLightList(PoserLightObj) or
    # addToLightList(objID, name, type)
    def addToLightList(self, light, *argv):
        if len(argv) > 0:
            # In this case light is the unique ID of the light
            if not light in self.lightList:
                self.lightList[light] = {"name": argv[0], "type": argv[1], "properties": {}}
                return True
            return False
        else:
            # In this case light is a Poser light object 
            lightID = light.InternalName()
            if not lightID in self.lightList:
                lightData = {}
                self.getLightData(light, lightData)
                self.lightList[lightID] = {
                  "name": light.Name(),
                  "type": light.LightType(),
                  "properties": lightData
                }
                return True
        return False

    def removeLightFromList(self, lightID):
        if lightID in self.lightList:
            del self.lightList[lightID]

    def hasLightChanged(self, light):
        lightID = light.InternalName()
        if not lightID in self.lightList:
            return False;
        lightData = {}
        self.getLightData(light, lightData)

        if self.lightList[lightID]["properties"] != lightData:
            self.lightList[lightID]["properties"] = lightData
            return True
        return False

    def getCamera(self, camera=None):
        """
        Store the camera data 
        """
        try:
            if not camera:
                # Grab the current camera data
                camera = poser.Scene().CurrentCamera()

            m = camera.WorldMatrix()
            focalLength = camera.ParameterByCode(poser.kParmCodeFOCAL).Value()
            fStop = camera.ParameterByCode(poser.kParmCodeFSTOP).Value()
            focalDistance = camera.ParameterByCode(poser.kParmCodeFOCUSDISTANCE).Value()
            hither = camera.ParameterByCode(poser.kParmCodeHITHER).Value()
            yon = camera.ParameterByCode(poser.kParmCodeYON).Value()
            # For future uses
            scale = 1.0
            scaleParam = camera.ParameterByCode(poser.kParmCodeASCALE)
            if scaleParam:
                scale = scaleParam.Value()

            cameraObj = { 
                "matrix" : m,
                "fstop" : fStop,
                "focalLength" : focalLength,
                "focalDistance" : focalDistance * PU2Meters,
                "hither" : hither * PU2Meters,
                "yon" : yon * PU2Meters,
                "name": camera.Name(),
                "ID": camera.InternalName(),
                "scale": scale
            }
            return cameraObj
        except Exception,e:
            Reality.writeToLog(
                "Exception in getCamera(): %s" % e.message
            )
            return {}

    ##
    # Poser 9 has a bug that prevents renaming of objects to be sent to the add on Framework
    # This happens only when the internal name of an object is changed as a result of the 
    # parenting. If we conform a hairprop and then change the parent the prop will change name
    # but the change is not reported to Reality. If then the user deletes that prop the 
    # old declaration of materials is still in Reality.
    # The following method tries to find the old name based on the assumption that the new
    # name has a suffix of type ":<digit>"
    #
    # By the same token, if we delete an object that has been parented after 
    # being added to the scene, that object will not be found because the 
    # parenting has changed its name form "objectName" to "objectName:1"
    def findRenamedObject(self, internalName, publicName):
        # Is this a parented object deleted from the main figure?
        objParts = internalName.rpartition(":")
        if objParts[1] == ":" and objParts[2].isdigit():
            if RealitySceneData.hasObject(objParts[0]):
                return objParts[0]
        # Then test if this is an object that has been un-parented
        objList = RealitySceneData.getObjectNames()
        for name in objList:
            if name.startswith(internalName):
                objParts = name.rpartition(":")
                if objParts[1] == ":":
                    if publicName == RealitySceneData.getObjectName(name):
                        return name
        return ""

    ##
    # Deletes one object from the database. The *objects* parameter is passed by Poser
    # and it's a sequence of tuples formed in this way:
    #     [0] - Name of the object
    #     [1] - Internal Name of the object. This is guaranteed to be unique
    #     [2] - A string that defines what type of object has been deleted. It's 
    #           one of "figure", "prop", actor", "light" or "camera".
    def deleteObjects(self, objects):
        deleteLights = False
        try:
            for obj in objects:
                # Reality.writeToLog("delete %s -- %s -- %s" % (obj[0],obj[1],obj[2]))
                if obj[2] in ("figure","prop","actor"):
                    # Reality.writeToLog("Deleting %s" % obj[0])
                    # Communicate with the server-side SceneData...
                    RealitySceneData.deleteObject(obj[0], True)
                elif obj[2] == "camera":
                    RealitySceneData.removeCamera(obj[1])
                    # Find what is the current selected camera
                    camID = poser.Scene().CurrentCamera().InternalName()
                    if camID:
                        RealitySceneData.selectCamera(camID)
                elif obj[2] == "light":
                    deleteLights = True

            """
            There is a bug in Poser 9 SR3 that causes the delete events for lights 
            to be sent after the add events. This causes the following scenerio:
              - When the user adds a light set all the existing lights are deleted
              - The lights from the new set are added to the scene
              - The "add objects" event is sent
              - The "delete objects" event is sent
            Since many lights re-use the same name we end up with no lights in Reality!
            The solution is to ignore the delete event and simply scan all the lights in the
            scene and re-add them after removing all the lights. This is inefficient but,
            at this time, it's the only way to fix the problem.
            """
            if deleteLights: 
                RealitySceneData.backupLights()
                RealitySceneData.removeAllLights()
                self.lightList = {}
                self.addAllLights()
                RealitySceneData.restoreLightsFromBackup()

        except Exception,e:
            # print "Exception in deleteObjects: " + e.message + ", " + obj[0]
            Reality.writeToLog("Exception in deleteObjects: " + e.message + ", " + obj[0])

    def renameObject(self, obj):
        try:
            newName = obj.Name()
            if isinstance(obj, poser.ActorType):
                isAreaLight = obj.IsLight() and obj.LightType() == ReTools.AreaLightType
                if obj.IsCamera():
                    try:
                        internalName = obj.InternalName()
                        if internalName in self.cameraList:
                            self.cameraList[internalName]["name"] = newName
                            # Communicate with the server-side SceneData...
                            RealitySceneData.renameCamera(internalName,newName)
                    except Exception, e:
                        Reality.writeToLog("Exception in renameObject/camera: " + e.message)

                elif newName.startswith("RealityLight"):
                    # The user might have added any object to the scene and then rename
                    # it to start with RealityLight to turn it into a light. In that
                    # case we need to remove the object from the list of objects and
                    # then add it as a light.
                    # objID = obj.InternalName()
                    objID = obj.CustomData(REALITY_ID)
                    if RealitySceneData.hasObject(objID):
                        # Communicate with the server-side SceneData...
                        RealitySceneData.deleteObject(objID, False)
                    # self.addMeshLight(obj)
                    self.addObjects([obj])

                elif obj.IsLight() and not isAreaLight:
                    try:
                        lightID = obj.InternalName()
                        if lightID in self.lightList:
                            self.lightList[lightID]["name"] = newName
                            self.lightList[lightID]["type"] = obj.LightType()
                            RealitySceneData.renameLight(lightID, newName)
                    except Exception, e:
                        print "Exception while renaming a light: " + e.message

                else:
                    # This is a prop object
                    try:
                        # objID = obj.InternalName()
                        objID = obj.CustomData(REALITY_ID)
                        if not objID:
                            Reality.writeToLog("Object %s has no Reality ID, cannot rename" % obj.Name())
                            return
                        if RealitySceneData.hasObject(objID):
                            # Communicate with the server-side SceneData...
                            RealitySceneData.renameObject(objID, newName)
                    except Exception, e:
                        Reality.writeToLog("Exception in renameObject/prop: %s" % (e.message,obj.Name()))
            elif isinstance(obj, poser.FigureType):
                # internalName = obj.InternalName()
                internalName = obj.CustomData(REALITY_ID)
                # Communicate with the server-side SceneData...
                RealitySceneData.renameObject(internalName,newName)

        except Exception, e:
            Reality.writeToLog("Exception in renameObject: " + e.message)


    ##
    # Sends the current data about all lights to the host-app side of Reality.
    # This is used before rendering a scene to make sure that position and 
    # orientation of all lights is current.
    def updateLights(self):
        for lightID in self.lightList:
            if lightID == "IBL":
                continue
            try:
                light = poser.Scene().ActorByInternalName(lightID)
                m = light.WorldMatrix()
                RealitySceneData.setLightMatrix(lightID, m)
            except Exception, e:
                Reality.writeToLog("Exception in updateLights() %s: %s" % (e.message, lightID))
                pass

    # def getRootObjects(self):
    #     return(self.rootObjects)

    def getLights(self):
        return(self.lightList)

    def getCameras(self):
        return(self.cameraList)
        
    def storeCameraData(self, camID, name, focalLength):
        self.cameraList[camID] = {"focalLength": focalLength, "name": name}

    def newScene(self):
        global Globals

        self.lightList   = {}
        self.cameraList  = {}
        Globals["lightsAdded"]    = False
        Globals["cameraData"]     = []
        Globals["selectedCamera"] = ""

# We hold one instance of the class for storage of the local data
RealityData = RealityDataModel()

##
# The RealityPane is the hosted Reality UI in Poser. This pane is not the main
# Reality UI but just a system to provide configuration data and feedback to the
# user. 
# It's also used to launch the Reality UI and render the current frame without
# calling the Reality UI
class RealityPane(wx.Panel):
    GUICaller = None
    # Used to keep track of the rotation of the IBL light, if any
    IBLRotation = 0

    ##
    # GUICaller is a reference to a method that is used to call up the 
    # main Reality GUI
    def __init__(self, parent, GUICaller, coreReality):

        self.GUICaller = GUICaller
        self.RealityCore = coreReality
        # Height of certain widgets
        wdglHeight = 24
        wx.Panel.__init__(self, parent)
        self.SetBackgroundColour(wx.Colour(73,73,73))

        self.mainBox    = wx.BoxSizer(wx.VERTICAL)
        self.buttonBox  = wx.BoxSizer(wx.HORIZONTAL)

        # Button to call Reality actual
        self.btnCallReality = wx.Button(self,label="Reality Render Editor", style=wx.BU_EXACTFIT, size=(160, wdglHeight))
        self.btnRenderFrame = wx.Button(self,label="Render Frame", style=wx.BU_EXACTFIT, size=(120, wdglHeight))

        # Create the panel layout
        # self.mainBox.Add(self.objectList, 1, wx.EXPAND | wx.TOP, 10)

        # A little spacer
        self.mainBox.Add((-1,5))
        self.mainBox.Add(self.buttonBox, 0, wx.EXPAND)

        self.buttonBox.Add(self.btnCallReality, 0, wx.EXPAND)
        self.buttonBox.Add(self.btnRenderFrame, 0, wx.EXPAND)
        # self.mainBox.Add((-1,20))
        self.SetSizer(self.mainBox)
        self.SetAutoLayout(True)
        self.mainBox.Fit(self)

        self.timer = wx.Timer(self)
        poser.WxApp().Bind(wx.EVT_TIMER, self.refreshRealityData, self.timer)
        self.timer.Start(RefreshRate)

        #
        # Event handlers
        # 

        # Call Reality actual
        poser.WxApp().Bind(wx.EVT_BUTTON, self.GUICaller, self.btnCallReality)        
        poser.WxApp().Bind(wx.EVT_BUTTON, self.renderSceneHandler, self.btnRenderFrame)        

    def renderSceneHandler(self, event):
        self.RealityCore.renderScene(True)

    def refreshRealityData(self, event):
        self.RealityCore.updateSceneData()

##
# The main class entry point. This is used to inject Reality into Poser. The code
# adds a menu option to start the rendering of the scene and it creates the hosted
# UI used to communicate with the Reality UI proper. The hosted UI is just used
# to provide some real-time feedback to the user and for debugging during development.

class RealityX( poseraddon.Addon,          
                poseraddon.SceneObserver,  
                poseraddon.SceneDataSaver, 
                poseraddon.PrefsSaver ):
    win = None

    # Temporarily disable the running of the callback during some crucial operations
    callbackDisabled = True

    # Flag to handle a bug in Poser 9 that causes the issue of the objectsDelete()
    # event after a new scene has been created and the stock objects have been created
    ignoreDeleteObjectEvent = False

    ##
    # Setup the basic plug-in info.
    def __init__(self):
        self.addonInfo['id']        = 'com.preta3d.Reality'
        self.addonInfo['author']    = 'Pret-a-3D'
        self.addonInfo['copyright'] = '(c) 2012 Pret-a-3D. All rights reserved.'
        self.addonInfo['name']      = 'Reality'
        self.addonInfo['version']   = '3.1'
        if ReTools.POSER_MAJOR > 9:
            self.addonInfo['apiversion'] = '1.2'
        self.addonInfo['observer']  = 1
        self.addonInfo['scenedata'] = 1
        self.addonInfo['prefsdata'] = 1


    ##
    # Creates the hosted, minimal, UI
    def setupUI(self):
        mgr = poser.WxAuiManager()        
        self.win = RealityPane(mgr.GetManagedWindow(),self.CallReality, self)
        mgr.AddPane(self.win, wx.aui.AuiPaneInfo()
            .Name("com.preta3d.Reality")
            .Caption("Reality Control Center")
            .DefaultPane()
            .FloatingSize(wx.Size(450, 300)))

    ##
    # Creates the Reality Render menu in Poser
    def addRenderMenu(self):
        mgr           = poser.WxAuiManager()
        win           = mgr.GetManagedWindow()
        menubar       = win.GetParent().GetMenuBar()
        renderMenu    = menubar.GetMenu(5)
        self.menuItem = wx.MenuItem(renderMenu, wx.ID_ANY, text="Reality Render Editor")
        renderMenu.AppendItem(self.menuItem)
        # This is the PID
        self.RealityProcess = 0
        poser.WxApp().Bind(wx.EVT_MENU, self.CallReality, self.menuItem)

    ##  
    # Remove the render menu
    def removeRenderMenu(self)  :
        mgr        = poser.WxAuiManager()
        win        = mgr.GetManagedWindow()
        menubar    = win.GetParent().GetMenuBar()
        renderMenu = menubar.GetMenu(5)
        poser.WxApp().Unbind(wx.EVT_MENU, self.CallReality, self.menuItem)
        renderMenu.removeItem(self.menuItem)

    ##
    # Poser 9 doesn't provide an API to set the scene as dirty so we simply created
    # a parameter into the Universe object and flip-flop it to force saving of the
    # scene when Reality's values are changed
    def setSceneAsDirty(self):
        try:
            if ReTools.POSER_MAJOR > 9:
                poser.Scene().Changed()
                return
            # Poser 9 workaround
            u = poser.Scene().ActorByInternalName("GROUND")
            if not u:
                return
            p = u.Parameter(RE_SCENE_DIRTY_PARAM)
            if not p:
                p = u.CreateValueParameter(RE_SCENE_DIRTY_PARAM)
            p.SetValue(2)
            p.SetValue(1)
        except Exception, e:
            Reality.writeToLog("Exception in setSceneAsDirty(): %s" % e.message)

    def checkFrameDimensions(self):
        if poser.Scene().RenderDimAutoscale() != 0:
            Reality.renderDimensionsNotSet()
            return False
        return True

    ##
    # Renders the scene via Reality
    def renderScene(self, runRenderer=True):
        global Globals
        # if not self.checkFrameDimensions():
        #     return
        # Refreshes the data for the lights
        RealityData.updateLights()
        frameNo = poser.Scene().Frame()
        sceneFileName = RealitySceneData.getSceneFileName(frameNo)

        RealitySceneData.renderSceneStart(sceneFileName, frameNo);

        # Export the geometry
        exporter = ReGeometryExporter(Globals)
        exporter.exportGeometry()

        RealitySceneData.renderSceneFinish(runRenderer == True)
        return sceneFileName

    ##
    # Renders the animation set in Poser
    def renderAnimation(self, runRenderer, selectedStartFrame, selecteEndFrame):
        global Globals
        sc = poser.Scene()
        # # We must do the test here or the message will popup for each frame of the animation
        # if not self.checkFrameDimensions():
        #     return
        currentFrame = sc.Frame()
        FPS = sc.FramesPerSecond()
        startFrame = 0
        endFrame = sc.NumFrames()-1

        selectedStartFrame = selectedStartFrame-1
        selecteEndFrame = selecteEndFrame-1
        if selectedStartFrame > 0:
            startFrame = selectedStartFrame
        if selecteEndFrame != 0:
            endFrame = selecteEndFrame

        # The renderQueue is a list of file names that are passed
        # to Lux for batch rendering
        renderQueue = []
        displayStyle = sc.DisplayStyle()
        sc.SetDisplayStyle(poser.kDisplayCodeHIDDENLINE)
        for frameNo in xrange(startFrame, endFrame+1):
            sc.SetFrame(frameNo)
            sc.DrawAll()
            self.updateCameraData()
            renderQueue.append(self.renderScene(False))

        if runRenderer:
            Reality.renderLuxQueue(renderQueue, RealitySceneData.getNumThreads())
            
        sc.SetFrame(currentFrame)
        self.updateCameraData()
        sc.SetDisplayStyle(displayStyle)

    def updateObjectsVisibility(self):
        # Work on the objects that are children of the Universe object
        sc = poser.Scene()
        uni = sc.ActorByInternalName("UNIVERSE")
        if not uni:
            return
        objs = sc.Figures()
        # Get all the root-level objects that are not figures, lights or cameras
        for act in uni.Children():
            if (not isinstance(act, poser.FigureType) and 
                isinstance(act, poser.ActorType) ):
                if not act.IsLight() and not act.IsCamera():
                    objs.append(act)
        # Set visibility
        for obj in objs:
            objID = obj.CustomData(REALITY_ID)
            if objID:
                RealitySceneData.setObjectVisible(objID, obj.Visible())


    # !TODO!
    def selectMaterial(self, objectID, materialID):
        Reality.writeToLog("Material selected: '%s:%s'" % (objectID, materialID))
        act = None
        try:
            act = poser.Scene().Figure(RealitySceneData.getObjectName(objectID))
        except:
            act = poser.Scene().Actor(RealitySceneData.getObjectName(objectID))
        if act:
            try:
                mat = act.Material(materialID)
                poser.Scene().SelectMaterial(mat)
            except Exception, e:
                print e.message

    def updateCameraData(self):
        # Update camera information
        currentCamera = poser.Scene().CurrentCamera()
        if currentCamera.InternalName() in RealityData.cameraList:
            # YROT is the yaw parameter for the camera
            yaw = currentCamera.ParameterByCode(poser.kParmCodeYROT)
            # Test if this is a perspective camera. If it is not
            # then yaw parameter does not exist for this camera
            if yaw:
                cameraData = RealityData.getCamera()
                cameraID = cameraData["ID"]
                if (Globals["selectedCamera"] != cameraID) or (Globals["cameraData"] != cameraData):
                    Globals["cameraData"]     = cameraData
                    Globals["selectedCamera"] = cameraID
                    RealitySceneData.updateCamera(cameraID, cameraData)

    def updateAnimationLimits(self):
        sc = poser.Scene()
        Reality.updateAnimationLimits(1, sc.NumFrames(), sc.FramesPerSecond())

    ##
    # Our mean of communicating between the C++ layer and the Poser Python layer
    # This method also refreshes the camera and light data 
    def updateSceneData(self):
        global Globals

        if self.callbackDisabled:
            return

        # When blanking the scene the poser.Scene() call is invalid
        # and the below statement fails. With the try clause we avoid
        # consequences and simply get out of here until the call is valid again
        try:
            currentObject = poser.Scene().CurrentActor()
        except:            
            return
        # No current object, the scene is empty, retry later
        if not currentObject:
            return
        fig = currentObject.ItsFigure()
        if fig != None:
            currentObjectName = fig.CustomData(REALITY_ID)
        else:
            currentObjectName = currentObject.CustomData(REALITY_ID)

        if currentObjectName:
            currentMat = poser.Scene().CurrentMaterial()
            currentMatName = ""
            if currentMat:
                currentMatName = currentMat.Name()
            objAndMat = "%s::%s" % (currentObjectName, currentMatName)
            if (objAndMat != Globals["lastObjMat"]):
                Globals["lastObjMat"] = objAndMat
                Reality.materialSelected(currentObjectName, currentMatName)

        self.updateCameraData()
        self.updateAnimationLimits()
        camID = poser.Scene().CurrentCamera().InternalName()
        RealitySceneData.selectCamera(camID)
        Reality.hostCameraSelected(camID);
        updateFrameDimensions()

        # Updating light data
        for light in poser.Scene().Lights():
            if RealityData.hasLightChanged(light):
                RealityData.updateLight(light)

            # Update the light position/rotation
            m = light.WorldMatrix()
            lightName = light.InternalName()
            RealitySceneData.setLightMatrix(lightName, m)

        # Update camera information
        currentCamera = poser.Scene().CurrentCamera()
        if currentCamera.InternalName() in RealityData.cameraList:
            # YROT is the yaw parameter for the camera
            yaw = currentCamera.ParameterByCode(poser.kParmCodeYROT)
            # Test if this is a perspective camera. If it is not
            # then yaw parameter does not exist for this camera
            if yaw:
                cameraData = RealityData.getCamera()
                cameraID = cameraData["ID"]
                if (Globals["selectedCamera"] != cameraID) or (Globals["cameraData"] != cameraData):
                    Globals["cameraData"]     = cameraData
                    Globals["selectedCamera"] = cameraID
                    RealitySceneData.updateCamera(cameraID, cameraData)

        # Update the rotation of the IBL Sphere, if presents
        try:
            IBLSphere = poser.Scene().ActorByInternalName("RealityIBLSphere");
            iblAngle = IBLSphere.ParameterByCode(poser.kParmCodeYROT).Value()
            if iblAngle != self.IBLRotation:
                self.IBLRotation = iblAngle
                try:
                    RealitySceneData.setIBLRotation(iblAngle)
                except Exception, e:
                    print "Exception in Reality.checkTimeEvent: %s" % e.message
        except:
            pass

        # Update the visibility flags
        self.updateObjectsVisibility()

        # Check if there are commands from the GUI 
        while (Reality.getNumCommands() > 0):
            cmd = Reality.commandStackPop()
            # Values in Reality have changed
            if cmd == "changed":
                self.setSceneAsDirty()
            # Render a frame
            elif cmd == "render":
                runRenderer = Reality.commandStackPop()
                self.renderScene(runRenderer == "1")
            # Render the animation
            elif cmd == "renderAnim":
                runRenderer = Reality.commandStackPop()
                startFrame  = int(Reality.commandStackPop())
                endFrame    = int(Reality.commandStackPop())
                self.renderAnimation(runRenderer == "1", startFrame, endFrame)
            # cmt = Change Material Type
            elif cmd == "cmt":
                objectID = Reality.commandStackPop()
                materialID = Reality.commandStackPop()
                newType  = Reality.ReMaterialType(int(Reality.commandStackPop()))
                RealityData.changeMaterialType(objectID, materialID, newType)
            # Select Material in Host App
            elif cmd == "smha":
                objectID = Reality.commandStackPop()
                materialID = Reality.commandStackPop()
                self.selectMaterial(objectID, materialID)
            # sip = Set IBL Preview
            elif cmd == "sip":
                previewMap = Reality.commandStackPop()
                ReSetIBLPreviewMap(previewMap)
            elif cmd == "refresh":
                self.refreshCatalog()
            elif cmd == "save":
                if ReTools.POSER_MAJOR > 9:
                    docName = poser.Scene().DocumentPath() 
                    if docName == None:
                        fd = wx.FileDialog(self.win, 
                                           style=wx.FD_SAVE, 
                                           message="Save Poser scene")
                        if not fd.ShowModal():
                            return
                        docName = fd.GetPath()
                        if not docName:
                            return;
                    poser.SaveDocument(docName)
                else:
                    wx.MessageBox("Sorry, but the Save Scene option of Reality only works with Poser 10 or above", "Information")

    def load(self):
        global Globals, RealityActive
        Reality.writeToLog("Running on %d-bit %s" % (bitness, machineOS)) 

        # Our own data
        self.rootNodes = []
        try:
            # Start the IPC services.
            Reality.startHostSideServices(Reality.HostAppID.Poser)

            # Identify ourselves
            Reality.setHostAppID("poser")

            # self.callbackInstalled = False

        except Exception, e:
            wx.MessageBox(
                """
                Could not start the communication with Reality.
                Please check your installation of Reality.
                """
            )
            RealityActive = False 

        # Finally load the menu and basic GUI 
        if RealityActive:
            Reality.setLibraryPaths(poser.Libraries())
            Reality.setHostVersion(("%d.%d.%d" % (ReTools.POSER_MAJOR, ReTools.POSER_MINOR, ReTools.POSER_PATCH_NUMBER)))
            self.addRenderMenu()
            self.setupUI()

    def unload(self):
        global RealityActive
        if RealityActive:
            Reality.closeGUI()
            Reality.stopHostSideServices()
            RealityActive = False
            Reality.writeToLog("Reality unloaded from Poser")

    ##
    # Call the Reality GUI
    def CallReality(self, event):
        if (not Reality.runGUI(RealityPath)):
            wx.MessageBox(
                """
                Could not lauch the Reality program using the path %s.\n 
                Please check the installation and try again
                """
                % RealityLibraryPath
            )

    ##
    # Even with the Add-on Framework there are situations where 
    # Poser doesn't notify plugins of the addition or removal of
    # objects. This method takes care of refreshing the scene from scratch
    def refreshCatalog(self):
        RealitySceneData.markObjectsForDeletion()
        newActors = []
        for actor in poser.Scene().Figures() + poser.Scene().Actors():
            ignorable = actor.IsBase() or actor.IsLight() or actor.IsCamera() or actor.IsBodyPart() \
                        or actor.IsDeformer() or actor.IsZone()
            if ignorable:
                continue        
            # found = RealitySceneData.clearObjectDeletionFlag(actor.InternalName())
            found = False
            rid = actor.CustomData(REALITY_ID)
            if rid:
                found = RealitySceneData.clearObjectDeletionFlag(rid)
            if not found:
                newActors.append(actor)
        RealitySceneData.deleteOrphanedObjects()
        if newActors:
            self.objectsAdded(newActors)
        self.ignoreDeleteObjectEvent = False

    #
    # Scene Observer methods
    #
    def objectsAdded(self, objects):
        if not RealityActive:
            return
        # We need to do this here because during the load()
        # phase the Scene object is invalid
        self.callbackDisabled = True
        RealityData.addObjects(objects)
        self.callbackDisabled = False

    ##
    # The objects array contains tuples organized as such:
    # [0] = Internal name of the object
    # [1] = External name of the object
    # [2] = A string describing if the object is a:
    #       prop, actor, light, figure, camera
    def objectsDeleted(self, objects):
        if not RealityActive:
            return
        if self.ignoreDeleteObjectEvent:
            self.ignoreDeleteObjectEvent = False
            return

        try:
            RealityData.deleteObjects(objects)
            #self.win.update()
        except Exception, e:
            print "Exception in objectsDeleted()" + e.message

    def objectSelected(self, obj):
        pass

    def objectsRenamed(self, objectsOldNames):
        if not RealityActive:
            return
        for (obj, oldName) in objectsOldNames:
            Reality.writeToLog("Rename: %s was %s now is %s" % (obj.InternalName(), oldName, obj.Name()))
            RealityData.renameObject(obj)
        #self.win.update()

    def lightsChanged(self):
        # For now this method is not very useful
        pass

    ##
    # The objects array is in the format:
    # [objectRef, oldName]
    def objectsInternalRenamed(self, objects): 
        # Disabled because we use our own object UID, which never changes
        # and is reliable
        pass

        # if not RealityActive:
        #     return
        # try:
        #     theObject = objects[0][0]
        #     oldName = objects[0][1]
        #     newName = theObject.InternalName()
        #     RealityData.renameObjectID( oldName, newName, theObject )
        # except Exception, e:
        #     print "Error in Reality.objectsInternalRenamed(): " + e.message

    
    def materialsChanged(self, materials):
        if not RealityActive:
            return
        Reality.pauseMaterialPreview(True)
        for matInfo in materials:
            RealityData.updateMaterial(matInfo[0],matInfo[1])
        Reality.pauseMaterialPreview(False)

    def sceneDeleting(self, scene):
        if not RealityActive:
            return
        try:
            self.callbackDisabled = True
            Globals["frameSize"] = (0,0)
            RealityData.newScene()
            RealitySceneData.newScene()
            Reality.setNewScene()

            #self.win.update()
            self.callbackDisabled = False
            if ReTools.POSER_MAJOR == 9:
                # Kludgey workaround for a bug in Poser 9 that
                # causes the deleteObjects() event to be called after 
                # a new scene is called. We need to tell our method to
                # ignore that call at this point.
                self.ignoreDeleteObjectEvent = True

        except Exception, e:
            print "Error in Reality.sceneDeleting(): " + e.message

    def sceneCreated(self, scene):
        if not RealityActive:
            return
        updateFrameDimensions()

    ##
    # Implements the interface from <poseraddon.SceneDataSaver> and
    # provides the system to store Reality data in this scene
    def saveData(self):
        if ReTools.POSER_MAJOR > 9:
            docName = poser.Scene().DocumentPath()
            # If the document is None then Poser is saving its own Preferred
            # Scene from the Preferences dialog box. So, we avoid storing
            # anything there.
            if not docName:
                Reality.writeToLog("Skipping saving Reality data in the Poser start scene")
                return
        try:
            if RealitySceneData.needsSaving():
              return RealitySceneData.exportScene()
        except Exception, e:
            print "Exception in Reality::saveData(): " + e.message

        return None

    def findFigureByName(self, figName):
        for fig in poser.Scene().Figures():
            if fig.Name() == figName:
                return fig.InternalName()
        return ""

    def verifyFigureIntegrity(self, data):
        """
        Verifies that the list of internal names of figures is the same
        as the one kept in the Reality data. Poser renames the figures
        when it reloads the pz3 file if there are gaps in the numbering
        of "Figure 1", "Figure 2"... "Figure n"
        """
        figures = {}
        # Create the dictionary with the list of the current figures
        for fig in poser.Scene().Figures():
            figures[fig.InternalName()] = fig.Name()
        # Compare the two dictionaries. If there is a mismatch return False
        for objKey in data["objects"]:
            obj = data["objects"][objKey]
            figName = obj["internalName"]
            if figName in figures:
                if obj["name"] != figures[figName]:
                    return False
            else:
                return False
        return True

    def rebuildListOfFigures(self, data):
        poserFigs = {}
        poserFigs2 = {}
        # Create the dictionary with the list of the current figures
        for fig in poser.Scene().Figures():
            poserFigs[fig.InternalName()] = fig.Name()
            poserFigs2[fig.Name()] = fig.InternalName()

        # Create a list with the conversions from old to new
        convTable = []
        for objKey in data["objects"].keys():
            if not objKey in poserFigs:
                objName = data["objects"][objKey]["name"]
                # This is not a figure but a prop
                if not objName in poserFigs2:
                    continue
                convTable.append( (objKey, poserFigs2[objName]) )
        # Rename our objects
        for (oldFigName, newFigName) in convTable:
            data["objects"][newFigName] = data["objects"][oldFigName]
            data["objects"][newFigName]["internalName"] = newFigName
            del data["objects"][oldFigName]

    ##
    # Implements the interface from <poseraddon.SceneDataSaver> and
    # provides the system to load Reality data from this scene
    def loadData(self, data):
        try:
            Reality.writeToLog("Loading Reality scene data")
        except:
            print "Error: Reality plugin not active"
            return

        if not RealityActive:
            Reality.writeToLog("Reality not active. Exiting loadData()")
            return
        try:
            global Globals
            Reality.setLibraryPaths(poser.Libraries())

            # Kludgey workaround for a bug in Poser that
            # causes the deleteObjects() event to be called after 
            # a new scene is called. We need to tell our method to
            # ignore that call at this point.
            self.ignoreDeleteObjectEvent = True

            RealitySceneData.restoreScene(data)

            # Link the objects that were saved before we started using our
            # own GUID to the GUIDs that have been generated when said 
            # objects have been added to the Poser scene.
            if not (data["mainVersion"] >= 4 and data["subVersion"] >= 1):
                Reality.writeToLog("Conversion of Reality data from older version")
                objects = data["objects"]
                for oldObjID in objects:
                    Reality.writeToLog("Converting %s/%s" % (oldObjID,objects[oldObjID]["name"]))
                    try:
                        obj = poser.Scene().Figure(objects[oldObjID]["name"])
                    except Exception, e:
                        try:
                            obj = poser.Scene().Actor(objects[oldObjID]["name"])
                        except Exception, e:
                            Reality.writeToLog("Error: \"%s\", for %s in loadData()" % (e.message, oldObjID))
                            continue

                    objName = obj.Name()
                    if objName.startswith("GoalCent")                \
                       or objName.startswith("CenterOfMass")         \
                       or objName.startswith("FocusDistanceControl") \
                       or obj.IsDeformer()                     \
                       or obj.IsBase()                         \
                       or obj.IsZone() :
                          continue

                    objID = ReGUID.makeObjectUID(obj)
                    obj.SetCustomData(REALITY_ID, objID, 0, 0)
                    Reality.writeToLog("Renaming %s to %s" % (oldObjID, objID))
                    RealitySceneData.renameObjectID(oldObjID, objID)

            # Restore the local list of lights
            for (objID, obj) in data["lights"].items():
                try:
                    if obj["type"] == ReTools.RealityIBLType :
                        continue
                    RealityData.addToLightList(objID, obj["name"], lightTypeToPoser.get(obj["type"], ReTools.SpotLightType))
                except Exception, e:
                    print "Error in Reality restore lights for %s: %s" % (objID, e.message)
                RealityData.addAllLights()
            # Restore the local list of cameras
            for (objID, obj) in data["cameras"].items():
                RealityData.storeCameraData(objID, obj["name"], obj["focalLength"])

        except Exception, e:
            print "Error in Reality::loadData(): " + e.message


    ##
    # Provides the required preference data to be saved in the Poser 
    # storage system
    def savePrefs(self):
        pass

    def loadPrefs(self, data):
        pass


#
# Registering the plug-in with Poser
#    
poser.RegisterAddon("com.preta3d.Reality", RealityX())
